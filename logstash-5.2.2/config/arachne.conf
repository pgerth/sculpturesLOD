input {
  # Read all documents from Arachne Elasticsearch matching the given query
  elasticsearch {
    hosts => "localhost:9300"
    index => "arachne4"
    query => '{ "query": { "match": { "facet_subkategorie_objekt": "Plastik" } } }'
    size => "20"
  }
}

filter{
#  if [places][0][relation] =~ "Fundort" {
#    mutate {add_field => {"[location][lon]" => "%{[places][0][location][lon]}"}}
#    mutate {add_field => {"[location][lat]" => "%{[places][0][location][lat]}"}}
#  }
#  if [places][1][relation] =~ "Fundort" {
#    mutate {add_field => {"[location][lon]" => "%{[places][1][location][lon]}"}}
#    mutate {add_field => {"[location][lat]" => "%{[places][1][location][lat]}"}}
#  }
#  if [places][2][relation] =~ "Fundort" {
#    mutate {add_field => {"[location][lon]" => "%{[places][2][location][lon]}"}}
#    mutate {add_field => {"[location][lat]" => "%{[places][2][location][lat]}"}}
#  }
#

  # dc mapping for identifier
  mutate {
    replace => { "type" => "arachne" }
    rename => { "title" => "dc:title" }
    rename => { "entityId" => "dc:identifier" }
    }

  # Mapping for nested location attributes to dc
  # create location only for the archaeological site, where the object was found
  if [places] {
  ruby {
      code => '
        place = event.get("[places]")
        array = Array.new
        i = 0

        place.each do |pl|
          if pl["relation"] == "Fundort"
            event.set("location", pl["location"])
          end
          array[i] = {}
          unless pl["location"]["lat"].nil?
            array[i]["wgs84:lat"] = pl["location"]["lat"]
          end
          unless pl["location"]["lon"].nil?
            array[i]["wgs84:lon"] = pl["location"]["lon"]
          end
          unless pl["name"].nil?
            array[i]["dc:title"] = pl["name"]
          end
          unless pl["gazetteerId"].nil?
            array[i]["@id"] = "https://gazetteer.dainst.org/place/" + pl["gazetteerId"].to_s
          end
          unless pl["relation"].nil?
            array[i]["dc:type"] = pl["relation"]
          end
          i += 1
        end
        unless array.nil?
          event.set("[dc:spatial]", array)
        end
        '
    }
  }
  # Mapping of the material terms to AAT
  if [facet_material] {
  ruby {
    code => '
      material = event.get("[facet_material][0]")
      materialDesc = event.get("[facet_materialbeschreibung][0]")

      aat = {
        "bronze" => "aat:300010957",
        "terrakotta" => "aat:300010669",
        "marmor" => "aat:300011443",
      }
      aat2 = {
        "weiÃŸer marmor" => "aat:300011571",
        "grauer marmor" => "aat:300011496",
        "schwarzer marmor" => "aat:300011484",
        "pentelisch" => "aat:300011599",
        "pentelisch" => "aat:300011571",
        "carrara" => "aat:300011576",
        "carrara" => "aat:300011571",
        "cipollino" => "aat:300011545",
        "marmor thasium" => "aat:300011607",
        "bianco e nero antico" => "aat:300311589",
        "breccia corallina" => "aat:300011453",
        "settebassi" => "aat:300011455",
        "giallo antico" => "aat:300011557",
        "rosso antico" => "aat:300011531",
      }
      i = 0
      array = Array.new
      aat.each {|key, value|
        if material.downcase.include?(key)
          array[i] = {}
          array[i]["@id"] = "#{value}"
          array[i]["dc:title"] = "#{key}"
          i += 1
        end
      }
      unless materialDesc.nil?
        aat2.each {|key, value|
          if materialDesc.downcase.include?(key)
            array[i] = {}
            array[i]["@id"] = "#{value}"
            array[i]["dc:title"] = "#{key}"
            i += 1
          end
        }
        event.set("[dc:medium][dc:description]", materialDesc)
      end
      event.set("dc:medium", array)
      '
    }
  }

  # dc mapping for other attributes
  mutate {
    rename => { "facet_datierungepoche" => "dc:temporal" }
    rename => { "facet_literatur" => "dc:bibliographicCitation" }
    rename => { "connectedEntities" => "dc:relation" }
    rename => { "images" => "dc:isReferencedBy" }
    rename => { "facet_subkategorie_objekt" => "dc:type" }
  }

  # remove not needed attributes
  mutate {remove_field => ["message","path","host","facet_land","thumbnailId","imageSize","facet_ort","facet_geo","facet_kategorie","degree","datasetGroup","subtitle","facet_image","ids","boost","lastModified","editorSection","fields","facet_ortsangabe","facet_datierungargument","facet_antikeroemprovinz","externalLinks","facet_fundort","facet_bearbeitungen","suggest","sections","facet_aufbewahrungsort","internalId","catalogIds","catalogPaths","facet_subkategorie_objekt","facet_antikegriechlandschaft","facet_fotonrextern","facet_fundkontext","facet_technik","facet_schmuckspezifizierung","facet_objektgattung","facet_kulturkreis","dates","places"]}
}

# all dc:subject
  # facet_kulturkreis =>
  # facet_fundkontext =>
  # facet_erhaltung => crm:condition state // schema:itemCondition

# schema:isBasedOn
  # schema:person =>
    # facet_geschlecht => schema:gender (value schema:Female / Male)
    # facet_lebensalter =>
  # facet_thema (z.B. satyr) => @id aat /dbpedia


output{
	elasticsearch {
	hosts => ["http://localhost:9200"]
	user => "elastic"
	password => "elastic"
	index => "object2"
	document_id => "%{dc:identifier}"
	}
}
