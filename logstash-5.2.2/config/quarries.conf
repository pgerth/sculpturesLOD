# Import of the csv file
input{
	file{
		path =>"/Users/phg/Documents/Development/sculpturesLOD/logstash-5.2.2/files/quarries.csv"
		start_position =>"beginning"
		sincedb_path => "/dev/null"
		type => "quarry"
	}
}
# Data conversions
filter{
	# Mapping of the csv colums to dc
	# Temporary attributes are not directly mapped to dc
	csv{
		columns => ["dc:title","lat","lon","Location","Country","Province","dc:description","AAT","dcterms:bibliographicCitation"]
		separator => "	"
	}
	# DC Mapping and refinement of the temporary attributes
	mutate {add_field => {"dc:identifier" => "%{dc:title}"}}
	mutate {gsub => ["dc:identifier", " ", "_"] lowercase => ["dc:identifier"]}
	mutate {add_field => {"@id" => "http://oxrep.classics.ox.ac.uk/databases/sites/%{Country}/%{dc:identifier}_quarry/"}}
	mutate {
		convert => ["lat","float"]
		convert => ["lon","float"]
		add_field => {"[location][lat]" => "%{lat}"}
		add_field => {"[location][lon]" => "%{lon}"}
		add_field => {"[dcterms:spatial][dcterms:isPartOf]" => "%{Country}"}
		add_field => {"[dcterms:spatial][wgs84:lat]" => "%{lat}"}
		add_field => {"[dcterms:spatial][wgs84:lon]" => "%{lon}"}
		add_field => {"[dcterms:spatial][dc:description]" => "%{Location}"}
		add_field => {"[dc:type]" => "aat:300000402"}
	}
	if [AAT] {
		mutate {add_field => {"[dc:format][@id]" => "%{AAT}"}}
	}
	# Analysing the material free text description for material terms and
	# Mapping of the material terms to AAT
	ruby {
		code => '
			material = event.get("[dc:description]")

			aat = {
				"limestone" => "aat:300011286",
				"sandstone" => "aat:300011376",
				"marble" => "aat:300011443",
				"white marble" => "aat:300011571",
				"white-grey marble" => "aat:300011571",
			 	"pentelic" => "aat:300011599"}
			i = 0
			array = Array.new
			aat.each {|key, value|
				if material.downcase.include?(key)
					array[i] = {}
					array[i]["@id"] = "#{value}"
					array[i]["dc:title"] = "#{key}"
					puts "#{value}"
					puts i
					i += 1
				end
			}
			event.set("[dc:medium]", array)
			'
		}
	# Mapping of mentioned place names to iDAI.gazetteer
	ruby {
		init => '
			require "net/http"
			require "json"
			require "open-uri"
			require "uri"'
		code => '
			title = event.get("[dc:title]")
			url = "https://gazetteer.dainst.org/search.json?q=" + title + "&sort=prefName.title.sort&offset=0&limit=1"
			uri = URI.encode(url)
			res = open(uri).read
			json = JSON.parse(res)
			event.set("[dcterms:spatial][@id]", json["result"][0]["@id"])
			'
		}
	# Romoval of not needed attributes and headline
	mutate {remove_field => ["message","path","host","Material","AAT","lat","lon","Country","Province","Location","tags"]}
	if [dc:title] == "Site" {drop {}}
}
# Injection of the data into the elasticsearch index
output{
  stdout { codec => json }
	elasticsearch {
	hosts => ["http://localhost:9200"]
	user => "elastic"
	password => "elastic"
	index => "place"
	document_id => "%{dc:identifier}"
	}
}
