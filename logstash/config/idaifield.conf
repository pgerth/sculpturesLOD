# Import of the csv file
input{
  stdin {}

}
# Data conversions
filter{
	# Mapping of the csv colums to dcterms
	# Temporary attributes are not directly mapped to dcterms
	csv{
		columns => ["id","FundNr","Projekt","dcterms:title","kulturkreis","KlassAll","KlassSpez","Kampagne","Breite","Hoehe","Tiefe","Gewicht","Material","MaterialBeschr","BauwerkID","BauwerkBeschr","Foto"]
		separator => "	"
	}
  # basic JSON-LD structure: @id, @context
  mutate {
    add_field => {"@context" => "http://localhost:9200/object/context/1/_source"}
    add_field => {"@id" => "http://idaifield.dainst.org/chimtou/%{id}"}
  }
  # dcterms mapping
  if [KlassAll] {
    mutate { add_field => {"dcterms:type" => "%{KlassAll}"} }
  }
  if [KlassSpez] {
    mutate { add_field => {"dcterms:description" => "%{KlassSpez}"} }
  }
  if [Projekt] {
    mutate { add_field => {"dcterms:identifier" => "%{Projekt} %{Kampagne} %{FundNr}"} }
  }
  # dcterms mapping of related datasets
  if [BauwerkID] {
    mutate {
      add_field => {"[dcterms:partOf][dcterms:title]" => "%{BauwerkID}"}
      add_field => {"[dcterms:partOf][dcterms:type]" => "Bauwerk"}
    }
    if [BauwerkBeschr] {
      mutate {add_field => {"[dcterms:partOf][dcterms:type]" => "%{BauwerkBeschr}"}}
    }
  }
  if [Foto] {
    mutate {
      add_field => {"[dcterms:isReferencedBy]" => "%{Foto}"}
    }
  }

  # remove not needed attributes
  mutate {
    remove_field => ["message","path","host","KlassAll","KlassSpez","Projekt","Kampagne","FundNr","BauwerkID","BauwerkBeschr","Foto"]
  }
}
# Injection of the data into the elasticsearch index
output{
	stdout { codec => rubydebug }
	elasticsearch {
		hosts => ["http://localhost:9200"]
		user => "elastic"
		password => "elastic"
		index => "idaifield"
		document_id => "%{id}"
	}
}
